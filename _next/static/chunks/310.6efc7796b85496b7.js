"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[310],{8310:function(n,e,r){r.r(e),r.d(e,{Fire:function(){return s}});var o=r(7437),t=r(2265),i=r(7316),a=r(7776);let c={defines:{ITERATIONS:"10",OCTIVES:"1"},uniforms:{fireTex:{type:"t",value:null},color:{type:"c",value:null},time:{type:"f",value:0},seed:{type:"f",value:0},invModelMatrix:{type:"m4",value:null},scale:{type:"v3",value:null},positionOffset:{type:"v3",value:new a.Vector3(0,0,0)},scaleOffset:{type:"v3",value:new a.Vector3(0,0,0)},noiseScale:{type:"v4",value:new a.Vector4(1,2,1,.3)},magnitude:{type:"f",value:1.3},lacunarity:{type:"f",value:2},gain:{type:"f",value:.5}}},s=n=>{let{fireTexture:e,color:r,...s}=n,l=(0,t.useRef)(),v=(0,i.F)(a.TextureLoader,e),x=(0,t.useRef)(new a.ShaderMaterial({defines:c.defines,uniforms:a.UniformsUtils.clone(c.uniforms),vertexShader:"#define GLSLIFY 1\nuniform vec3 scaleOffset;\nuniform vec3 positionOffset;\nvarying vec3 vWorldPos;\n\nvoid main() {\n  vec4 transformedPosition = vec4(position * scaleOffset + positionOffset, 1.0);\n  //vec4 transformedPosition = vec4(position * scaleOffset, 1.0);\n  gl_Position = projectionMatrix * modelViewMatrix * transformedPosition;\n  vWorldPos = (modelMatrix * vec4(position, 1.0)).xyz;\n\n  //gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n  //vWorldPos = (modelMatrix * vec4(position, 1.0)).xyz;\n}\n",fragmentShader:"#define GLSLIFY 1\nuniform vec3 color;\nuniform float time;\nuniform float seed;\nuniform mat4 invModelMatrix;\nuniform vec3 scale;\n\nuniform vec4 noiseScale;\nuniform float magnitude;\nuniform float lacunarity;\nuniform float gain;\n\nuniform sampler2D fireTex;\n\nvarying vec3 vWorldPos;\n\n// Simplex noise function by ashima / https://github.com/ashima/webgl-noise/blob/master/src/noise3D.glsl\nvec3 mod289(vec3 x) {\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n    return mod289(((x * 34.0) + 1.0) * x);\n}\n\nvec4 taylorInvSqrt(vec4 r) {\n    return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec3 v) {\n    const vec2 C = vec2(1.0 / 6.0, 1.0 / 3.0);\n    const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n    vec3 i  = floor(v + dot(v, C.yyy));\n    vec3 x0 = v - i + dot(i, C.xxx);\n\n    vec3 g = step(x0.yzx, x0.xyz);\n    vec3 l = 1.0 - g;\n    vec3 i1 = min(g.xyz, l.zxy);\n    vec3 i2 = max(g.xyz, l.zxy);\n\n    vec3 x1 = x0 - i1 + C.xxx;\n    vec3 x2 = x0 - i2 + C.yyy;\n    vec3 x3 = x0 - D.yyy;\n\n    i = mod289(i);\n    vec4 p = permute(permute(permute(\n        i.z + vec4(0.0, i1.z, i2.z, 1.0))\n        + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n        + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n    float n_ = 0.142857142857;\n    vec3 ns = n_ * D.wyz - D.xzx;\n\n    vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n    vec4 x_ = floor(j * ns.z);\n    vec4 y_ = floor(j - 7.0 * x_);\n\n    vec4 x = x_ * ns.x + ns.yyyy;\n    vec4 y = y_ * ns.x + ns.yyyy;\n    vec4 h = 1.0 - abs(x) - abs(y);\n\n    vec4 b0 = vec4(x.xy, y.xy);\n    vec4 b1 = vec4(x.zw, y.zw);\n\n    vec4 s0 = floor(b0) * 2.0 + 1.0;\n    vec4 s1 = floor(b1) * 2.0 + 1.0;\n    vec4 sh = -step(h, vec4(0.0));\n\n    vec4 a0 = b0.xzyw + s0.xzyw * sh.xxyy;\n    vec4 a1 = b1.xzyw + s1.xzyw * sh.zzww;\n\n    vec3 p0 = vec3(a0.xy, h.x);\n    vec3 p1 = vec3(a0.zw, h.y);\n    vec3 p2 = vec3(a1.xy, h.z);\n    vec3 p3 = vec3(a1.zw, h.w);\n\n    vec4 norm = taylorInvSqrt(vec4(dot(p0, p0), dot(p1, p1), dot(p2, p2), dot(p3, p3)));\n    p0 *= norm.x;\n    p1 *= norm.y;\n    p2 *= norm.z;\n    p3 *= norm.w;\n\n    vec4 m = max(0.6 - vec4(dot(x0, x0), dot(x1, x1), dot(x2, x2), dot(x3, x3)), 0.0);\n    m = m * m;\n    return 42.0 * dot(m * m, vec4(dot(p0, x0), dot(p1, x1), dot(p2, x2), dot(p3, x3)));\n}\n\nfloat turbulence(vec3 p) {\n    float sum = 0.0;\n    float freq = 1.0;\n    float amp = 1.0;\n\n    for(int i = 0; i < OCTIVES; i++) {\n        sum += abs(snoise(p * freq)) * amp;\n        freq *= lacunarity;\n        amp *= gain;\n    }\n\n    return sum;\n}\n\nvec4 samplerFire(vec3 p, vec4 scale) {\n    vec2 st = vec2(sqrt(dot(p.xz, p.xz)), p.y);\n\n    if(st.x <= 0.0 || st.x >= 1.0 || st.y <= 0.0 || st.y >= 1.0) return vec4(0.0);\n\n    p.y -= (seed + time) * scale.w;\n    p *= scale.xyz;\n\n    st.y += sqrt(st.y) * magnitude * turbulence(p);\n\n    if(st.y <= 0.0 || st.y >= 1.0) return vec4(0.0);\n\n    return texture2D(fireTex, st);\n}\n\nvec3 localize(vec3 p) {\n    return (invModelMatrix * vec4(p, 1.0)).xyz;\n}\n\nvoid main() {\n    vec3 rayPos = vWorldPos;\n    vec3 rayDir = normalize(rayPos - cameraPosition);\n    float rayLen = 0.0288 * length(scale.xyz);\n\n    vec4 col = vec4(0.0);\n\n    for(int i = 0; i < ITERATIONS; i++) {\n        rayPos += rayDir * rayLen;\n\n        vec3 lp = localize(rayPos);\n\n        lp.y += 0.5;\n        lp.xz *= 2.0;\n        col += samplerFire(lp, noiseScale);\n    }\n\n    col.a = col.r;\n\n    gl_FragColor = col;\n}\n\n",transparent:!0,depthWrite:!1,depthTest:!1})).current;return v.magFilter=a.LinearFilter,v.minFilter=a.LinearFilter,v.wrapS=a.ClampToEdgeWrapping,v.wrapT=a.ClampToEdgeWrapping,x.uniforms.fireTex.value=v,x.uniforms.color.value=r||new a.Color(15658734),x.uniforms.invModelMatrix.value=new a.Matrix4,x.uniforms.scale.value=new a.Vector3(1,1,1),x.uniforms.positionOffset.value=new a.Vector3(0,0,0),x.uniforms.scaleOffset.value=new a.Vector3(4.1,4.1,4.1),x.uniforms.seed.value=19.19*Math.random(),(0,i.C)((n,e)=>{l.current&&(l.current.material.uniforms.time.value+=e,l.current.material.uniforms.invModelMatrix.value.copy(l.current.matrixWorld))}),(0,o.jsxs)("mesh",{ref:l,children:[(0,o.jsx)("boxGeometry",{args:[1,1,1]}),(0,o.jsx)("primitive",{object:x,attach:"material"})]})}}}]);